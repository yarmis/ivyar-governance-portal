/**
 * IVYAR Autopilot v8 - Updated Worker with Custom System Prompts
 * Supports module-specific AI assistants
 */

interface Env {
  ANTHROPIC_API_KEY: string;
  AUTOPILOT_CACHE: KVNamespace;
}

interface ConversationMessage {
  role: 'user' | 'assistant';
  content: string;
}

interface StreamRequest {
  scenario: string; // Now supports any module name
  userMessage: string;
  conversationHistory: ConversationMessage[];
  systemPrompt?: string; // NEW: Custom system prompt from frontend
}

// ============================================================================
// DEFAULT SCENARIOS (Fallback)
// ============================================================================

const DEFAULT_SCENARIOS: Record<string, string> = {
  general_inquiry: `You are the IVYAR Platform AI Assistant. You help users understand IvyAR's platform and navigate to the right modules.`,
  
  voting_navigation: `You are the IVYAR Voting Assistant. You help users navigate voting processes.`,
  
  technical_support: `You are the IVYAR Technical Support Assistant. You help users resolve technical issues.`,
};

/**
 * CORS headers
 */
const CORS_HEADERS = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};

/**
 * Handle OPTIONS requests
 */
function handleOptions(): Response {
  return new Response(null, {
    status: 204,
    headers: CORS_HEADERS,
  });
}

/**
 * Health check
 */
function handleHealth(): Response {
  const health = {
    status: 'ok',
    service: 'autopilot',
    version: '8.1.0', // Updated version
    features: [
      'custom_system_prompts',
      'module_specific_assistants',
      'sse_streaming',
    ],
    supportedModules: [
      'materials',
      'zoning',
      'violations',
      'donors',
      'us_construction',
      'geo_utilities',
      'procurement',
      'general',
    ],
    timestamp: new Date().toISOString(),
  };

  return new Response(JSON.stringify(health, null, 2), {
    status: 200,
    headers: {
      'Content-Type': 'application/json',
      ...CORS_HEADERS,
    },
  });
}

/**
 * Stream Claude responses with custom system prompts
 */
async function handleStream(request: Request, env: Env): Promise<Response> {
  try {
    const body = await request.json() as StreamRequest;
    const { scenario, userMessage, conversationHistory = [], systemPrompt } = body;

    // Validate user message
    if (!userMessage || typeof userMessage !== 'string') {
      return new Response(
        JSON.stringify({ error: 'userMessage is required and must be a string' }),
        {
          status: 400,
          headers: {
            'Content-Type': 'application/json',
            ...CORS_HEADERS,
          },
        }
      );
    }

    // Use custom system prompt if provided, otherwise use default
    const effectiveSystemPrompt = systemPrompt || 
      DEFAULT_SCENARIOS[scenario] || 
      DEFAULT_SCENARIOS.general_inquiry;

    // Build conversation messages
    const messages: Array<{ role: string; content: string }> = [
      ...conversationHistory,
      { role: 'user', content: userMessage },
    ];

    // Create SSE stream
    const { readable, writable } = new TransformStream();
    const writer = writable.getWriter();
    const encoder = new TextEncoder();

    // Stream in background
    (async () => {
      try {
        const response = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': env.ANTHROPIC_API_KEY,
            'anthropic-version': '2023-06-01',
          },
          body: JSON.stringify({
            model: 'claude-sonnet-4-20250514',
            max_tokens: 4096,
            system: effectiveSystemPrompt, // Use custom or default prompt
            messages: messages,
            stream: true,
          }),
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Anthropic API error: ${response.status} - ${errorText}`);
        }

        const reader = response.body?.getReader();
        if (!reader) {
          throw new Error('No response body from Anthropic API');
        }

        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const data = line.slice(6);
              
              if (data === '[DONE]') {
                continue;
              }

              try {
                const parsed = JSON.parse(data);

                // Content block delta
                if (parsed.type === 'content_block_delta' && parsed.delta?.text) {
                  await writer.write(
                    encoder.encode(`event: text\ndata: ${JSON.stringify({ text: parsed.delta.text })}\n\n`)
                  );
                }

                // Message usage
                if (parsed.type === 'message_delta' && parsed.usage) {
                  await writer.write(
                    encoder.encode(`event: usage\ndata: ${JSON.stringify(parsed.usage)}\n\n`)
                  );
                }

                // Stream end
                if (parsed.type === 'message_stop') {
                  await writer.write(
                    encoder.encode(`event: done\ndata: ${JSON.stringify({ 
                      status: 'completed',
                      module: scenario
                    })}\n\n`)
                  );
                }
              } catch (parseError) {
                console.error('Failed to parse SSE data:', parseError);
              }
            }
          }
        }
      } catch (error) {
        console.error('Stream error:', error);
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        await writer.write(
          encoder.encode(`event: error\ndata: ${JSON.stringify({ error: errorMessage })}\n\n`)
        );
      } finally {
        await writer.close();
      }
    })();

    return new Response(readable, {
      status: 200,
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        ...CORS_HEADERS,
      },
    });
  } catch (error) {
    console.error('Request handling error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    
    return new Response(
      JSON.stringify({ error: 'Failed to process request', details: errorMessage }),
      {
        status: 500,
        headers: {
          'Content-Type': 'application/json',
          ...CORS_HEADERS,
        },
      }
    );
  }
}

/**
 * Main Worker fetch handler
 */
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const path = url.pathname;

    // Handle CORS preflight
    if (request.method === 'OPTIONS') {
      return handleOptions();
    }

    // Route handlers
    if (path === '/autopilot/health' || path === '/autopilot/health/') {
      return handleHealth();
    }

    if (path === '/autopilot/stream' || path === '/autopilot/stream/') {
      if (request.method !== 'POST') {
        return new Response(
          JSON.stringify({ error: 'Method not allowed. Use POST.' }),
          {
            status: 405,
            headers: {
              'Content-Type': 'application/json',
              ...CORS_HEADERS,
            },
          }
        );
      }
      return handleStream(request, env);
    }

    // 404 for unknown routes
    return new Response(
      JSON.stringify({
        error: 'Not found',
        availableEndpoints: [
          'GET /autopilot/health',
          'POST /autopilot/stream',
        ],
        version: '8.1.0',
      }),
      {
        status: 404,
        headers: {
          'Content-Type': 'application/json',
          ...CORS_HEADERS,
        },
      }
    );
  },
};
