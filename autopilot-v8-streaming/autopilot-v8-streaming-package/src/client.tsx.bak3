/**
 * AUTOPILOT V8 - STREAMING CLIENT COMPONENT
 * React component for consuming streaming API responses
 * 
 * Features:
 * - Real-time streaming updates
 * - Progress indicators
 * - Cache status display
 * - Error handling
 */

'use client';

import { useState, useCallback, useRef } from 'react';

// ============================================================================
// TYPES
// ============================================================================

interface StreamChunk {
  type: 'start' | 'content' | 'complete' | 'error';
  data: any;
  timestamp: number;
}

interface EvaluationResult {
  decision: 'approve' | 'conditional_approve' | 'reject' | 'refer';
  risk_level: 'low' | 'medium' | 'high' | 'critical';
  explanation: string;
  conditions?: string[];
  audit_log?: any;
  cached?: boolean;
  cache_age_seconds?: number;
}

interface StreamingState {
  isStreaming: boolean;
  content: string;
  result: EvaluationResult | null;
  error: string | null;
  startTime: number | null;
  endTime: number | null;
  cacheHit: boolean;
}

// ============================================================================
// STREAMING API CLIENT
// ============================================================================

class AutopilotStreamingClient {
  private apiUrl: string;

  constructor(apiUrl: string) {
    this.apiUrl = apiUrl;
  }

  /**
   * Standard evaluation (with caching)
   */
  async evaluate(
    documentType: string,
    scenario: string,
    data: Record<string, any>,
    options?: {
      cacheEnabled?: boolean;
      cacheTTL?: number;
    }
  ): Promise<EvaluationResult> {
    const response = await fetch(`${this.apiUrl}/autopilot/evaluate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        documentType,
        scenario,
        data,
        options
      })
    });

    if (!response.ok) {
      throw new Error(`Evaluation failed: ${response.statusText}`);
    }

    const cacheStatus = response.headers.get('X-Cache');
    const result = await response.json();
    
    return {
      ...result,
      cacheHit: cacheStatus === 'HIT'
    };
  }

  /**
   * Streaming evaluation
   */
  async *streamEvaluate(
    documentType: string,
    scenario: string,
    data: Record<string, any>,
    options?: {
      cacheEnabled?: boolean;
      cacheTTL?: number;
    }
  ): AsyncGenerator<StreamChunk, void, unknown> {
    const response = await fetch(`${this.apiUrl}/autopilot/stream`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        documentType,
        scenario,
        data,
        options
      })
    });

    if (!response.ok) {
      throw new Error(`Stream failed: ${response.statusText}`);
    }

    const reader = response.body?.getReader();
    if (!reader) {
      throw new Error('No response body');
    }

    const decoder = new TextDecoder();
    let buffer = '';

    try {
      while (true) {
        const { done, value } = await reader.read();
        
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        
        // Process complete messages
        const lines = buffer.split('\n\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.slice(6);
            try {
              const chunk: StreamChunk = JSON.parse(data);
              yield chunk;
            } catch (e) {
              console.error('Failed to parse chunk:', data);
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }

  /**
   * Invalidate cache
   */
  async invalidateCache(pattern?: string): Promise<{ deleted_keys: number }> {
    const response = await fetch(`${this.apiUrl}/autopilot/cache/invalidate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ pattern })
    });

    if (!response.ok) {
      throw new Error(`Cache invalidation failed: ${response.statusText}`);
    }

    return await response.json();
  }
}

// ============================================================================
// REACT HOOK
// ============================================================================

export function useAutopilotStreaming(apiUrl: string) {
  const [state, setState] = useState<StreamingState>({
    isStreaming: false,
    content: '',
    result: null,
    error: null,
    startTime: null,
    endTime: null,
    cacheHit: false
  });

  const clientRef = useRef<AutopilotStreamingClient | null>(null);

  if (!clientRef.current) {
    clientRef.current = new AutopilotStreamingClient(apiUrl);
  }

  const streamEvaluate = useCallback(async (
    documentType: string,
    scenario: string,
    data: Record<string, any>,
    options?: { cacheEnabled?: boolean; cacheTTL?: number }
  ) => {
    setState({
      isStreaming: true,
      content: '',
      result: null,
      error: null,
      startTime: Date.now(),
      endTime: null,
      cacheHit: false
    });

    try {
      const client = clientRef.current!;
      
      for await (const chunk of client.streamEvaluate(documentType, scenario, data, options)) {
        switch (chunk.type) {
          case 'start':
            // Stream started
            break;

          case 'content':
            setState(prev => ({
              ...prev,
              content: prev.content + chunk.data.text
            }));
            break;

          case 'complete':
            setState(prev => ({
              ...prev,
              isStreaming: false,
              result: chunk.data,
              endTime: Date.now(),
              cacheHit: chunk.data.cached || false
            }));
            break;

          case 'error':
            setState(prev => ({
              ...prev,
              isStreaming: false,
              error: chunk.data.error,
              endTime: Date.now()
            }));
            break;
        }
      }
    } catch (error: any) {
      setState(prev => ({
        ...prev,
        isStreaming: false,
        error: error.message || 'Streaming failed',
        endTime: Date.now()
      }));
    }
  }, []);

  const evaluate = useCallback(async (
    documentType: string,
    scenario: string,
    data: Record<string, any>,
    options?: { cacheEnabled?: boolean; cacheTTL?: number }
  ) => {
    setState({
      isStreaming: true,
      content: '',
      result: null,
      error: null,
      startTime: Date.now(),
      endTime: null,
      cacheHit: false
    });

    try {
      const client = clientRef.current!;
      const result = await client.evaluate(documentType, scenario, data, options);
      
      setState({
        isStreaming: false,
        content: result.explanation || '',
        result,
        error: null,
        startTime: state.startTime,
        endTime: Date.now(),
        cacheHit: result.cacheHit || false
      });
    } catch (error: any) {
      setState(prev => ({
        ...prev,
        isStreaming: false,
        error: error.message || 'Evaluation failed',
        endTime: Date.now()
      }));
    }
  }, [state.startTime]);

  const invalidateCache = useCallback(async (pattern?: string) => {
    const client = clientRef.current!;
    return await client.invalidateCache(pattern);
  }, []);

  const reset = useCallback(() => {
    setState({
      isStreaming: false,
      content: '',
      result: null,
      error: null,
      startTime: null,
      endTime: null,
      cacheHit: false
    });
  }, []);

  return {
    ...state,
    streamEvaluate,
    evaluate,
    invalidateCache,
    reset,
    processingTime: state.startTime && state.endTime 
      ? state.endTime - state.startTime 
      : null
  };
}

// ============================================================================
// UI COMPONENTS
// ============================================================================

interface AutopilotStreamingUIProps {
  apiUrl: string;
  documentType: string;
  scenario: string;
  data: Record<string, any>;
  useStreaming?: boolean;
  cacheEnabled?: boolean;
}

export function AutopilotStreamingUI({
  apiUrl,
  documentType,
  scenario,
  data,
  useStreaming = true,
  cacheEnabled = true
}: AutopilotStreamingUIProps) {
  const {
    isStreaming,
    content,
    result,
    error,
    cacheHit,
    processingTime,
    streamEvaluate,
    evaluate,
    reset
  } = useAutopilotStreaming(apiUrl);

  const handleEvaluate = async () => {
    if (useStreaming) {
      await streamEvaluate(documentType, scenario, data, { cacheEnabled });
    } else {
      await evaluate(documentType, scenario, data, { cacheEnabled });
    }
  };

  return (
    <div className="space-y-6">
      {/* Controls */}
      <div className="flex gap-4">
        <button
          onClick={handleEvaluate}
          disabled={isStreaming}
          className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
        >
          {isStreaming ? 'Оброблення...' : 'Оцінити документ'}
        </button>

        {result && (
          <button
            onClick={reset}
            className="px-6 py-3 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors"
          >
            Скинути
          </button>
        )}
      </div>

      {/* Status Bar */}
      {(isStreaming || result || error) && (
        <div className="bg-gray-800 border border-gray-700 rounded-lg p-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              {isStreaming && (
                <div className="animate-spin w-5 h-5 border-2 border-blue-500 border-t-transparent rounded-full" />
              )}
              
              <div className="text-sm">
                {isStreaming && <span className="text-blue-400">Обробка...</span>}
                {result && !isStreaming && (
                  <span className="text-green-400">✓ Завершено</span>
                )}
                {error && <span className="text-red-400">✗ Помилка</span>}
              </div>
            </div>

            <div className="flex items-center gap-4 text-xs text-gray-400">
              {cacheHit && (
                <span className="flex items-center gap-1">
                  <span className="w-2 h-2 bg-green-500 rounded-full"></span>
                  Кеш
                </span>
              )}
              
              {processingTime !== null && (
                <span>{processingTime}ms</span>
              )}
              
              {useStreaming && (
                <span className="flex items-center gap-1">
                  <span className="w-2 h-2 bg-blue-500 rounded-full animate-pulse"></span>
                  Stream
                </span>
              )}
            </div>
          </div>
        </div>
      )}

      {/* Streaming Content (real-time) */}
      {isStreaming && content && (
        <div className="bg-gray-900 border border-gray-700 rounded-lg p-6">
          <h3 className="text-sm font-semibold text-gray-400 mb-3">
            Відповідь в реальному часі:
          </h3>
          <div className="text-gray-300 whitespace-pre-wrap font-mono text-sm">
            {content}
            <span className="inline-block w-2 h-4 bg-blue-500 animate-pulse ml-1"></span>
          </div>
        </div>
      )}

      {/* Error Display */}
      {error && (
        <div className="bg-red-900/20 border border-red-700 rounded-lg p-6">
          <h3 className="text-red-400 font-semibold mb-2">Помилка</h3>
          <p className="text-gray-300">{error}</p>
        </div>
      )}

      {/* Final Result */}
      {result && !isStreaming && (
        <div className="space-y-4">
          {/* Decision Card */}
          <div className={`border rounded-lg p-6 ${
            result.decision === 'approve' ? 'bg-green-900/20 border-green-700' :
            result.decision === 'conditional_approve' ? 'bg-yellow-900/20 border-yellow-700' :
            result.decision === 'reject' ? 'bg-red-900/20 border-red-700' :
            'bg-blue-900/20 border-blue-700'
          }`}>
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-xl font-bold text-white">
                {result.decision === 'approve' && '✓ Схвалено'}
                {result.decision === 'conditional_approve' && '⚠ Умовно схвалено'}
                {result.decision === 'reject' && '✗ Відхилено'}
                {result.decision === 'refer' && '→ Перенаправлено'}
              </h3>
              
              <span className={`px-3 py-1 rounded-full text-xs font-semibold ${
                result.risk_level === 'low' ? 'bg-green-500/20 text-green-400' :
                result.risk_level === 'medium' ? 'bg-yellow-500/20 text-yellow-400' :
                result.risk_level === 'high' ? 'bg-orange-500/20 text-orange-400' :
                'bg-red-500/20 text-red-400'
              }`}>
                Ризик: {result.risk_level}
              </span>
            </div>

            <p className="text-gray-300 mb-4">{result.explanation}</p>

            {result.conditions && result.conditions.length > 0 && (
              <div className="bg-gray-800/50 rounded p-4">
                <h4 className="text-sm font-semibold text-gray-400 mb-2">Умови:</h4>
                <ul className="list-disc list-inside space-y-1 text-gray-300 text-sm">
                  {result.conditions.map((condition, i) => (
                    <li key={i}>{condition}</li>
                  ))}
                </ul>
              </div>
            )}
          </div>

          {/* Performance Metrics */}
          <div className="bg-gray-800 border border-gray-700 rounded-lg p-4">
            <h4 className="text-sm font-semibold text-gray-400 mb-3">Метрики продуктивності</h4>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
              <div>
                <div className="text-gray-400">Час обробки</div>
                <div className="text-white font-mono">{processingTime}ms</div>
              </div>
              <div>
                <div className="text-gray-400">Кеш</div>
                <div className="text-white font-mono">
                  {cacheHit ? '✓ HIT' : '✗ MISS'}
                </div>
              </div>
              <div>
                <div className="text-gray-400">Режим</div>
                <div className="text-white font-mono">
                  {useStreaming ? 'Stream' : 'Standard'}
                </div>
              </div>
              <div>
                <div className="text-gray-400">Вік кешу</div>
                <div className="text-white font-mono">
                  {result.cache_age_seconds ? `${result.cache_age_seconds}s` : 'N/A'}
                </div>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// ============================================================================
// USAGE EXAMPLE
// ============================================================================

export function AutopilotDemoPage() {
  const sampleData = {
    company_name: "ТОВ Інноваційні Рішення",
    edrpou: "12345678",
    contract_value: 500000,
    delivery_terms: "30 днів",
    payment_terms: "передоплата 50%"
  };

  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-3xl font-bold text-white mb-8">
        Autopilot v8 - Streaming Demo
      </h1>

      <AutopilotStreamingUI
        apiUrl="https://ivyar-api.ivyar-gov.workers.dev"
        documentType="procurement"
        scenario="under_threshold"
        data={sampleData}
        useStreaming={true}
        cacheEnabled={true}
      />
    </div>
  );
}
